---
title: "Summary of Control-FREEC output (CNVs)"
author: Robert Allaway
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: 
  html_document:
    toc: true
    number_sections: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    fig_width: 7
    fig_height: 6
    fig_caption: true
    df_print: paged 
---

# Intro 

This notebook looks at the results from Control-FREEC, which allows us to estimate CNVs from WGS data generated with the cNF cell lines without WGS data from patient-matched tumor control tissue/cells.

First, let's get the dat and order the samples in the way we want them to show up on the final plot (e.g. paired cell lines together, primary, then immortalized.)

```{r echo=TRUE, message=FALSE, warning=FALSE}
library(synapser)
library(dplyr)
library(ggplot2)
synLogin()


query <- synTableQuery("SELECT * FROM syn35928271.2")$asDataFrame() 

bed_ents <- lapply(query$id, synGet)

beds <- lapply(bed_ents, function(x){
  readr::read_delim(x$path, col_names = c('chr','start','end','value1'))
  })

bed_names <- lapply(bed_ents, function(x) {stringr::str_remove(x$properties$name, ".bed")}) 

names(beds) <- bed_names

reorder_beds <- c("28cNF", "i28cNF", "cNF04.9a", "icNF04.9a", "cNF00.10a", "icNF00.10a", "cNF97.2a", "icNF97.2a", "cNF97.2b", "icNF97.2b", "cNF98.4c", "icNF98.4c", "cNF98.4d", "icNF98.4d")

beds <- beds[reorder_beds]

```

# Genome level heatmap of CNVs

Now, let's adapt a guide from the [ComplexHeatmap manual](https://jokergoo.github.io/ComplexHeatmap-reference/book/genome-level-heatmap.html) to plot a heatmap that faithfully represents the relative chromosome lengths and is a nicer presentation of the results. We can grab the BED files from Synapse, use a function to average the copy number across each region using window approach where each window is 1e4 bp long.  


```{r echo=TRUE, message=FALSE, warning=FALSE}
library(ComplexHeatmap)
library(circlize)
library(GenomicRanges)
library(EnrichedHeatmap)

## Modified from https://jokergoo.github.io/ComplexHeatmap-reference/book/genome-level-heatmap.html?q=genome#genome-level-heatmap

#In average_in_window() function, there are following arguments:
#window: A GRanges object of the genomic windows.
# gr: A GRanges object of the genomic signals.
# v: A vector or a matrix. This is the value associated with gr and it should have the same length or nrow as gr. v can be numeric or character. If it is missing or NULL, a value of one is assign to every region in gr. If v is numeric, it can be a vector or a matrix, and if v is character, it can only be a vector.
# method: Method to summarize the signals for every genomic window.
# empty_v: The default value for the window if no region in gr overlaps to it.

# The function returns a matrix with the same row length and order as window.
# Note, this function is "adapted from HilbertCurve package since there is similar task there."


average_in_window = function(window, gr, v, method = "weighted", empty_v = NA) {

    if(missing(v)) v = rep(1, length(gr))
    if(is.null(v)) v = rep(1, length(gr))
    if(is.atomic(v) && is.vector(v)) v = cbind(v)

    v = as.matrix(v)
    if(is.character(v) && ncol(v) > 1) {
        stop("`v` can only be a character vector.")
    }

    if(length(empty_v) == 1) {
        empty_v = rep(empty_v, ncol(v))
    }

    u = matrix(rep(empty_v, each = length(window)), nrow = length(window), ncol = ncol(v))

    mtch = as.matrix(findOverlaps(window, gr))
    intersect = pintersect(window[mtch[,1]], gr[mtch[,2]])
    w = width(intersect)
    v = v[mtch[,2], , drop = FALSE]
    n = nrow(v)

    ind_list = split(seq_len(n), mtch[, 1])
    window_index = as.numeric(names(ind_list))
    window_w = width(window)

    if(is.character(v)) {
        for(i in seq_along(ind_list)) {
            ind = ind_list[[i]]
            if(is.function(method)) {
                u[window_index[i], ] = method(v[ind], w[ind], window_w[i])
            } else {
                tb = tapply(w[ind], v[ind], sum)
                u[window_index[i], ] = names(tb[which.max(tb)])
            }
        }
    } else {
        if(method == "w0") {
            gr2 = reduce(gr, min.gapwidth = 0)
            mtch2 = as.matrix(findOverlaps(window, gr2))
            intersect2 = pintersect(window[mtch2[, 1]], gr2[mtch2[, 2]])

            width_intersect = tapply(width(intersect2), mtch2[, 1], sum)
            ind = unique(mtch2[, 1])
            width_setdiff = width(window[ind]) - width_intersect

            w2 = width(window[ind])

            for(i in seq_along(ind_list)) {
                ind = ind_list[[i]]
                x = colSums(v[ind, , drop = FALSE]*w[ind])/sum(w[ind])
                u[window_index[i], ] = (x*width_intersect[i] + empty_v*width_setdiff[i])/w2[i]
            }

        } else if(method == "absolute") {
            for(i in seq_along(ind_list)) {
                u[window_index[i], ] = colMeans(v[ind_list[[i]], , drop = FALSE])
            }
            
        } else if(method == "weighted") {
            for(i in seq_along(ind_list)) {
                ind = ind_list[[i]]
                u[window_index[i], ] = colSums(v[ind, , drop = FALSE]*w[ind])/sum(w[ind])
            }
        } else {
            if(is.function(method)) {
                for(i in seq_along(ind_list)) {
                    ind = ind_list[[i]]
                    u[window_index[i], ] = method(v[ind], w[ind], window_w[i])
                }
            } else {
                stop("wrong method.")
            }
        }
    }

    return(u)
}

chr_df = read.chromInfo(species = 'hg38')$df
chr_df = chr_df[chr_df$chr %in% paste0("chr", 1:22), ]
chr_gr = GRanges(seqnames = chr_df[, 1], ranges = IRanges(chr_df[, 2] + 1, chr_df[, 3]))
chr_gr

chr_window = makeWindows(chr_gr, w = 1e4)
chr_window

num_mat = NULL
for(i in 1:14) {
    bed = beds[[i]]
    gr_cnv = GRanges(seqnames = bed$chr, ranges = IRanges(bed$start, bed$end))

    num_mat = cbind(num_mat, average_in_window(chr_window, gr_cnv, bed[, 4]))
}

colnames(num_mat) <- reorder_beds

chr = as.vector(seqnames(chr_window))
chr_level = paste0("chr", 1:22)
chr = factor(chr, levels = chr_level)

ha_col <- HeatmapAnnotation(Status = rep(c("primary", "immortalized"),7),
                            col = list(Status = c("primary" = "#2A7F62", "immortalized" = "#F6BD60")))

ht_list <- Heatmap(num_mat, name = "Copy\nNumber", 
                  col = colorRamp2(c(0, 2, 4, 8), c("#0068EF", "#FFFFFF", "#FF729F", "#CC0041")),
                  row_split = chr, 
                  cluster_rows = FALSE, 
                  cluster_columns = FALSE,
                  row_title_rot = 0, 
                  row_title_gp = gpar(fontsize = 10), 
                  border = TRUE,
                  row_gap = unit(3, "points"),
                  width = 1, 
                  height = 1,
                  heatmap_height = unit(1,"npc"),
                  heatmap_width = unit(1,"npc"),
                  use_raster = F,
                  bottom_annotation = ha_col) 

```

## Results

The results match the previous results, with a couple of cell lines appearing to have large deletions in a couple of chromosomes. However, because these deletions are (1) very large, and (2) not consistent between the primary and immortalized cell lines and (3) cNF are thought to be pretty quiet, I suspect that these are probably a sequencing artifact. While not in scope for this paper, it might be worth trying some other CNV calling methods, especially if we can find patient-matched non-tumor WGS data. 

```{r fig.height=15, fig.width=6}
## this fails to render on my work mac for whatever reason, but seems to be ok in r 3.6 on a a linux instance
draw(ht_list, merge_legend = TRUE)

pdf("../figures/cnv_heatmap_1e4.pdf", width = 6, height = 15)
draw(ht_list, merge_legend = TRUE)
dev.off()

```

Out of curiosity, let's try a couple of other window sizes, larger and smaller:

5e3

```{r echo=TRUE, message=FALSE, warning=FALSE}



chr_df = read.chromInfo(species = 'hg38')$df
chr_df = chr_df[chr_df$chr %in% paste0("chr", 1:22), ]
chr_gr = GRanges(seqnames = chr_df[, 1], ranges = IRanges(chr_df[, 2] + 1, chr_df[, 3]))
chr_gr


chr_window = makeWindows(chr_gr, w = 5e3)

chr_window

num_mat = NULL

for(i in 1:14) {
    bed = beds[[i]]
    gr_cnv = GRanges(seqnames = bed$chr, ranges = IRanges(bed$start, bed$end))

    num_mat = cbind(num_mat, average_in_window(chr_window, gr_cnv, bed[, 4]))
}

colnames(num_mat) <- reorder_beds

chr = as.vector(seqnames(chr_window))
chr_level = paste0("chr", 1:22)
chr = factor(chr, levels = chr_level)

ha_col <- HeatmapAnnotation(Status = rep(c("primary", "immortalized"),7),
                            col = list(Status = c("primary" = "#2A7F62", "immortalized" = "#F6BD60")))

ht_list <- Heatmap(num_mat, name = "Copy\nNumber", 
                  col = colorRamp2(c(0, 2, 4, 8), c("#0068EF", "#FFFFFF", "#FF729F", "#CC0041")),
                  row_split = chr, 
                  cluster_rows = FALSE, 
                  cluster_columns = FALSE,
                  row_title_rot = 0, 
                  row_title_gp = gpar(fontsize = 10), 
                  border = TRUE,
                  row_gap = unit(3, "points"),
                  width = 1, 
                  height = 1,
                  heatmap_height = unit(1,"npc"),
                  heatmap_width = unit(1,"npc"),
                  use_raster = F,
                  bottom_annotation = ha_col) 

```


```{r fig.height=15, fig.width=6}

draw(ht_list, merge_legend = TRUE)


pdf("../figures/cnv_heatmap_5e3.pdf", width = 6, height = 15)
draw(ht_list, merge_legend = TRUE)
dev.off()

```

1e5 

```{r echo=TRUE, message=FALSE, warning=FALSE}


chr_df = read.chromInfo(species = 'hg38')$df
chr_df = chr_df[chr_df$chr %in% paste0("chr", 1:22), ]
chr_gr = GRanges(seqnames = chr_df[, 1], ranges = IRanges(chr_df[, 2] + 1, chr_df[, 3]))
chr_gr

chr_window = makeWindows(chr_gr, w = 1e5)
chr_window

num_mat = NULL
for(i in 1:14) {
    bed = beds[[i]]
    gr_cnv = GRanges(seqnames = bed$chr, ranges = IRanges(bed$start, bed$end))

    num_mat = cbind(num_mat, average_in_window(chr_window, gr_cnv, bed[, 4]))
}

colnames(num_mat) <- reorder_beds

chr = as.vector(seqnames(chr_window))
chr_level = paste0("chr", 1:22)
chr = factor(chr, levels = chr_level)

ha_col <- HeatmapAnnotation(Status = rep(c("primary", "immortalized"),7),
                            col = list(Status = c("primary" = "#2A7F62", "immortalized" = "#F6BD60")))

ht_list <- Heatmap(num_mat, name = "Copy\nNumber", 
                  col = colorRamp2(c(0, 2, 4, 8), c("#0068EF", "#FFFFFF", "#FF729F", "#CC0041")),
                  row_split = chr, 
                  cluster_rows = FALSE, 
                  cluster_columns = FALSE,
                  row_title_rot = 0, 
                  row_title_gp = gpar(fontsize = 10), 
                  border = TRUE,
                  row_gap = unit(3, "points"),
                  width = 1, 
                  height = 1,
                  heatmap_height = unit(1,"npc"),
                  heatmap_width = unit(1,"npc"),
                  use_raster = F,
                  bottom_annotation = ha_col) 
```


```{r fig.height=15, fig.width=6}

draw(ht_list, merge_legend = TRUE)


pdf("../figures/cnv_heatmap_1e5.pdf", width = 6, height = 15)

draw(ht_list, merge_legend = TRUE)
dev.off()

```

```{r}

sessionInfo()

```

